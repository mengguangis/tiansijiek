<html>

<head>
<title>Fragment Globe</title>
<meta charset ="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">  <!-- Use Chrome Frame in IE --> 
</head>

<body>
<div id="message" style="position:absolute;top:100px"></div> <!-- Pixel offset to avoid FPS counter -->
<canvas id="canvas" style="border: none;" width="800" height="600" tabindex="1"></canvas>

<script type="text/javascript" src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
<script type="text/javascript" src="three/three.js"></script>
<script type="text/javascript" src="three/OBJLoader.js"></script>
<script type="text/javascript" src="three/MTLLoader.js"></script>
<script type="text/javascript" src="three/OBJMTLLoader.js"></script>


<script id="pass_vs" type="x-shader/x-vertex">    
    precision highp float;

    uniform mat4 u_Model;
    uniform mat4 u_View;
    uniform mat4 u_Persp;
    uniform mat4 u_InvTrans;

    attribute vec3 Position;
    attribute vec3 Normal;
    attribute vec2 Texcoord;

    varying vec3 fs_Normal;
    varying vec4 fs_Position;
    varying vec2 fs_Texcoord;

    void main(void) {
        fs_Normal = ((u_InvTrans*vec4(Normal,0.0)).xyz);
        vec4 world = u_Model * vec4(Position, 1.0);
        vec4 camera = u_View * world;
        fs_Position = camera;
        gl_Position = u_Persp * camera;
        fs_Texcoord = Texcoord;
    }
</script>

<script id="pass_fs" type="x-shader/x-fragment">
    #extension GL_EXT_draw_buffers : require
    precision highp float;

    uniform vec3 u_Color;
    //uniform sampler2D u_ColorSampler;

    //in
    varying vec3 fs_Normal;
    varying vec4 fs_Position;
    varying vec2 fs_Texcoord;

    void main(void)
    {
        //normal, position, depth, color
        gl_FragData[0] = vec4(normalize(fs_Normal.xyz), 1.0);
        gl_FragData[1] = fs_Position;
        gl_FragData[2] = vec4(u_Color, 1.0);
        gl_FragData[3] = vec4(fs_Texcoord, 0.0,0.0);
        //vec4(0.0, 0.0, 1.0, 1.0);
        //gl_FragData[3] = vec4(0.0, 0.0, 0.0, 1.0);

        //gl_FragColor = vec4(vec3(0.2), 1.0);
    }
</script>


<script id="shade_vs" type="x-shader/x-vertex">
    precision highp float;

    attribute vec3 Position;
    attribute vec2 Texcoord;

    varying vec2 fs_Texcoord;

    void main() {
        fs_Texcoord = Texcoord * 0.5 + vec2(0.5);
        gl_Position = vec4(Position,1.0);
    }
</script>

<script id="light_fs" type="x-shader/x-fragment">
    precision highp float;
    #extension GL_EXT_draw_buffers : require
   

    #define DISPLAY_DEPTH 0
    #define DISPLAY_NORMAL 1
    #define DISPLAY_POSITION 2
    #define DISPLAY_COLOR 3
    #define DISPLAY_TOTAL 4
    #define DISPLAY_LIGHTS 5
    #define TILESIZE 32    
    #define LIGHTNUM 100
 

    uniform sampler2D u_Depthtex;
    uniform sampler2D u_Normaltex;
    uniform sampler2D u_Positiontex;
    uniform sampler2D u_Colortex;

    //for light
    uniform sampler2D u_LightGridtex;
    uniform sampler2D u_LightIndextex;
    uniform sampler2D u_LightPositiontex;
    uniform sampler2D u_LightColorRadiustex;
    uniform int u_LightNum;

    uniform int u_DisplayType;
    uniform float u_Far;
    uniform float u_Near;
    uniform float u_Width;
    uniform float u_Height;

    uniform int u_TileSize;
    //uniform Light u_Lights[LIGHTNUM];
    uniform int u_LightIndexImageSize;
    uniform float u_FloatLightIndexSize;
    uniform float u_WidthTile;
    uniform float u_HeightTile;

    varying vec2 fs_Texcoord;

    float linearizeDepth(float exp_depth, float near, float far) {
        return  (2.0 * near) / (far + near -  exp_depth * (far - near)); 
    }

    void main(void)
    {
        vec3 normal = texture2D(u_Normaltex, fs_Texcoord).xyz;
        vec3 position = texture2D(u_Positiontex, fs_Texcoord).xyz;
        vec3 color = texture2D(u_Colortex, fs_Texcoord).xyz;
        //vec3 depth = texture2D(u_Depthtex, fs_Texcoord).xyz;

        //float exp_depth = texture2D(u_Depthtex, fs_Texcoord).r;
        //float lin_depth = linearizeDepth(exp_depth,u_Near,u_Far);

        if(u_DisplayType == DISPLAY_LIGHTS){           
            //get the grid data index
            vec2 gridIndex = vec2(((fs_Texcoord.x*u_Width) / float(u_TileSize)) / (u_WidthTile), ((fs_Texcoord.y*u_Height) / float(u_TileSize)) / (u_HeightTile));
            //x for offset, y for count
            vec3 gridInfo = texture2D(u_LightGridtex, gridIndex).xyz;
            int offset = int(gridInfo.x);
            int count = int(gridInfo.y);   

            vec3 lightColor = vec3(0.0);
            int lightCount = 0;
            if(count > 0){
                for(int i = 0; i < LIGHTNUM; i++){
                    if(i < count){

                        int lightId;    
                        float temp = (mod(float(offset+i), u_FloatLightIndexSize));
                        //precesion problem
                        if(temp == u_FloatLightIndexSize)
                           temp = 0.0;

                        float lightSize =  u_FloatLightIndexSize-1.0;

                        vec2 dataIndex = vec2(
                             temp / lightSize,
                            floor(float((offset+i) / (u_LightIndexImageSize))) / lightSize
                            );                          
                      
                        //vec2 dataIndex = vec2(float(offset+i) / float(u_LightIndexImageSize-1), 1.0);
                        lightId = int((texture2D(u_LightIndextex, dataIndex).x));

                        vec3 lightPos = texture2D(u_LightPositiontex, vec2(float(lightId)/float(u_LightNum-1))).xyz;
                        vec4 lightColorRadius = texture2D(u_LightColorRadiustex, vec2(float(lightId)/float(u_LightNum-1))).xyzw;

                        if(distance(lightPos, position) < lightColorRadius.w){

                            //float distoL = distance(lightPos, position);
                            //distoL = max(lightColorRadius.w - distoL, 0.0);
                            float diffuse = max(dot(normal, normalize(lightPos - position)),0.0);                           
                            lightColor += diffuse * lightColorRadius.xyz;// * ((lightColorRadius.w - distance(lightPos, position)) / lightColorRadius.w);
                            //lightColor += lightColorRadius.xyz;
                            //if(distoL > 0.0)
                            lightCount ++;
                        }                         
                    }
                    else
                        break;
                }
                lightColor /= float(lightCount);                
                //lightColor = vec3(float(lightCount) / float(LIGHTNUM)) * 3.0;// * lightColor;
            }       
            gl_FragData[0] = vec4(lightColor, 1.0);// + vec4(color * 0.3,1.0);
        }
        else
            gl_FragData[0] = vec4(vec3(0.0), 1.0);
    }
</script>


<script id="nontilelight_fs" type="x-shader/x-fragment">
    precision highp float;
    //#extension GL_EXT_draw_buffers : require   

    #define DISPLAY_DEPTH 0
    #define DISPLAY_NORMAL 1
    #define DISPLAY_POSITION 2
    #define DISPLAY_COLOR 3
    #define DISPLAY_TOTAL 4
    #define DISPLAY_TILE_LIGHTS 5
    #define DISPLAY_NONTILE_LIGHTS 6

    uniform int u_DisplayType;
    uniform sampler2D u_Depthtex;
    uniform sampler2D u_Normaltex;
    uniform sampler2D u_Positiontex;
    uniform sampler2D u_Colortex;

    uniform vec4 u_Light;
    uniform vec3 u_LightColor;

    varying vec2 fs_Texcoord;
    
    void main()
    {
        vec3 normal = texture2D(u_Normaltex, fs_Texcoord).xyz;
        vec3 position = texture2D(u_Positiontex, fs_Texcoord).xyz;
        vec3 color = texture2D(u_Colortex, fs_Texcoord).xyz;
        vec3 light = u_Light.xyz;
        float lightRadius = u_Light.w;


         if( u_DisplayType == DISPLAY_NONTILE_LIGHTS )
        {            
            if(distance(light, position) < lightRadius){
                float diffuse = max(dot(normal, normalize(light - position)),0.0);
                gl_FragData[0] = vec4(diffuse * u_LightColor * color, 1.0);// * ((lightRadius- distance(light, position)) / lightRadius), 0.0);
            }
            else
                gl_FragData[0] = vec4(0.0,0.0,0.0, 0.0);   
        }
    }
</script>


<script id="diagnostic_fs" type="x-shader/x-fragment">
    #extension GL_EXT_draw_buffers : require
    precision highp float;

    #define DISPLAY_DEPTH 0
    #define DISPLAY_NORMAL 1
    #define DISPLAY_POSITION 2
    #define DISPLAY_COLOR 3
    #define DISPLAY_TOTAL 4
    #define DISPLAY_LIGHTS 5    

    uniform sampler2D u_Depthtex;
    uniform sampler2D u_Normaltex;
    uniform sampler2D u_Positiontex;
    uniform sampler2D u_Colortex;  

    uniform int u_DisplayType;
    uniform float u_Far;
    uniform float u_Near;
    uniform float u_Width;
    uniform float u_Height;

    uniform vec4 u_Light;  

    varying vec2 fs_Texcoord;

    float linearizeDepth(float exp_depth, float near, float far) {
        return  (2.0 * near) / (far + near -  exp_depth * (far - near)); 
    }   
    
    void main(void)
    {
        vec3 depth = texture2D(u_Depthtex, fs_Texcoord).xyz;

        float exp_depth = texture2D(u_Depthtex, fs_Texcoord).r;
        float lin_depth = linearizeDepth(exp_depth,u_Near,u_Far);

        vec3 normal = normalize(texture2D(u_Normaltex, fs_Texcoord).xyz);
        vec3 position = texture2D(u_Positiontex, fs_Texcoord).xyz;
        vec3 color = texture2D(u_Colortex, fs_Texcoord).xyz;
        

        vec3 light = u_Light.xyz;//.position.xyz;
        //u_Light.xyz;
        float diffuse = max(dot(normal, normalize(light - position)),0.0);

        if(u_DisplayType == DISPLAY_DEPTH)
            gl_FragData[0] = vec4(vec3(lin_depth), 1.0);
        else if(u_DisplayType == DISPLAY_NORMAL)
            gl_FragData[0] = vec4(abs(normal), 1.0);
        else if(u_DisplayType == DISPLAY_POSITION)
            gl_FragData[0] = vec4(abs(position)/u_Far, 1.0);
        else if(u_DisplayType == DISPLAY_COLOR)
            gl_FragData[0] = vec4(color, 1.0);
        else if(u_DisplayType == DISPLAY_TOTAL)
        {
            gl_FragData[0] = vec4(diffuse * color , 1.0);      
            //if(diffuse == 0.0)
             //   gl_FragData[0] = vec4(color,1.0);
        }
        else
            gl_FragData[0] = vec4(vec3(0.0), 1.0);      
            //gl_FragData[0] = vec4(diffuse * color, 1.0);      
    }
</script>


<script id="ambient_fs" type="x-shader/x-fragment">
    #extension GL_EXT_draw_buffers : require
    precision highp float;

    uniform sampler2D u_Depthtex;
    uniform sampler2D u_Normaltex;
    uniform sampler2D u_Positiontex;
    uniform sampler2D u_Colortex;

    uniform int u_DisplayType;

    varying vec2 fs_Texcoord;
    void main(void)
    {     
        vec3 depth = texture2D(u_Depthtex, fs_Texcoord).xyz;
        vec3 normal = texture2D(u_Normaltex, fs_Texcoord).xyz;
        vec3 position = texture2D(u_Positiontex, fs_Texcoord).xyz;
        vec3 color = texture2D(u_Colortex, fs_Texcoord).xyz;

        gl_FragData[0] = vec4(vec3(0.0), 1.0);
    }
</script>


<script id="post_vs" type="x-shader/x-vertex">
    precision highp float;

    attribute vec3 Position;
    attribute vec2 Texcoord;

    varying vec2 fs_Texcoord;

    void main() {
        fs_Texcoord = Texcoord * 0.5 + vec2(0.5);
        gl_Position = vec4(Position,1.0);
    }

</script>


<script id="post_fs" type="x-shader/x-fragment">    
    precision highp float;
    uniform sampler2D u_Posttex;

    varying vec2 fs_Texcoord;
    varying vec4 out_Color;

    void main(void)
    {       
        vec3 out_Color = texture2D(u_Posttex, fs_Texcoord).xyz;
        gl_FragColor = vec4(out_Color, 1.0);
    }

</script>

<script src ="extension.js" type ="text/javascript"></script>
<script src ="Stats.js" type ="text/javascript"></script>
<script src ="gl-matrix.js" type ="text/javascript"></script>
<script src ="webGLUtility.js" type ="text/javascript"></script>
<script src="webgl-obj-loader.js" type = "text/javascript"></script>
<script src ="deferred.js" type ="text/javascript"></script>

</body>

</html>
